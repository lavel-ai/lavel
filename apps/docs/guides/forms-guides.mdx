# Introduction

This guide outlines how to implement forms in the Lavel AI platform while properly addressing all cross-cutting concerns using React 19 features. Following this architecture ensures consistency, data quality, and a great user experience.

## Architecture Principles for Forms

Our form implementations should adhere to these key principles:

- **Data Quality**: All user input undergoes normalization, validation, and sanitization
- **Tenant Isolation**: All operations respect tenant boundaries
- **Authentication and Authorization**: Proper access controls at every level
- **Error Handling**: Consistent error handling and user feedback
- **Analytics**: Comprehensive tracking of user interactions and form events
- **Feature Flags**: Support for feature toggling and experimentation
- **Resource Management**: Optimize loading of stylesheets and scripts
- **Optimistic Updates**: Provide immediate feedback for key operations

## Step-by-Step Implementation Guide

### 1. Define Entity Schema and Normalization Rules

Start by defining your entity schema using Zod:

```typescript
// packages/schema/src/entities/entity-name.ts
import { z } from 'zod';

export const entitySchema = z.object({
  name: z.string().min(1, "Name is required"),
  // Additional fields...
});

export type Entity = z.infer<typeof entitySchema>;

// Optional fields for updates
export const entityUpdateSchema = entitySchema.partial();
```

Best practices for schema definition:
- Include meaningful validation error messages
- Use consistent patterns for similar fields across entities
- Consider internationalization for error messages

### 2. Create Normalization and Sanitization Functions

Leverage our utility functions for data normalization and sanitization:

```typescript
// Reference to existing implementations
// packages/schema/src/utils/normalize.ts - for text normalization
// packages/schema/src/utils/sanitize.ts - for security sanitization
```

Create a pipeline for your entity that applies these functions:

```typescript
// packages/schema/src/pipeline/entity-pipeline.ts
import { normalizeText } from '../utils/normalize';
import { sanitizeText } from '../utils/sanitize';

export async function processEntityData(data, context = {}) {
  // Follow the linear pipeline flow:
  // 1. Sanitize (security)
  // 2. Normalize (standardization)
  // 3. Validate (schema)
  
  // Track changes for transparency
  const changes = [];
  
  // Implementation details...
  
  return {
    result: processedData,
    changes,
    errors: []
  };
}
```

### 3. Implement Database Queries

Create the database schema and query functions following our standard pattern:

```typescript
// packages/database/src/tenant-app/schema/entity-name.ts
// packages/database/src/tenant-app/queries/entity-name-queries.ts
```

Database query best practices:
- Separate schema definition from query implementation
- Include proper error handling with detailed logs
- Implement tenant isolation at the query level
- Create dedicated functions for each operation

### 4. Leverage Analytics Integration

Our application uses the `@repo/analytics` package for comprehensive tracking. Integrate it into your form implementation by:

#### Client-side Analytics

Use existing components rather than reimplementing them:

1. **Form Tracking**: Use `TrackedForm` from `@repo/analytics/posthog/components/tracked-form`
   ```tsx
   import { TrackedForm } from '@repo/analytics/posthog/components/tracked-form';
   
   // In your form component:
   <TrackedForm 
     formType="entity_creation"
     entityType="entity"
     entityId={isEditing ? entity.id : undefined}
     properties={{
       // Additional properties
     }}
   >
     {/* Form fields */}
   </TrackedForm>
   ```

2. **Entity View Tracking**: Use `EntityViewTracker` from `@repo/analytics/posthog/components/entity-view-tracker`
   ```tsx
   import { EntityViewTracker } from '@repo/analytics/posthog/components/entity-view-tracker';
   
   // In your entity detail component:
   <EntityViewTracker
     entityType="entity"
     entityId={entity.id}
     properties={{
       // Additional context
     }}
   />
   ```

3. **Manual Event Tracking**: Use the `useAnalytics` hook
   ```tsx
   import { useAnalytics } from '@repo/analytics/posthog/client';
   
   // In your component:
   const analytics = useAnalytics();
   
   // Track custom event
   const handleAction = () => {
     analytics.capture('custom_action', {
       action_type: 'specific_action',
       // Additional properties
     });
   };
   ```

#### Server-side Analytics

Use the server-side tracking utilities:

```typescript
import { 
  trackFormSuccess, 
  trackFormError,
  trackEntityCreated, 
  trackEntityUpdated, 
  trackEntityDeleted 
} from '@repo/analytics/posthog/actions/server-actions';

// In your server action:
await trackFormSuccess({
  userId: user.id,
  formType: 'entity_creation',
  processingTimeMs: performance.now() - startTime,
  normalizationChanges,
});

await trackEntityCreated({
  userId: user.id,
  entityType: 'entity',
  entityId: created.id.toString(),
  tenantId: user.tenantId,
});
```

### 5. Integrate Observability

Leverage the `@repo/observability` package for error tracking and monitoring:

1. **Error Handling**: Use the error utilities in server actions and components
   ```typescript
   import { captureError } from '@repo/observability/error';
   
   // In your error handling:
   try {
     // Your code
   } catch (error) {
     captureError(error, {
       context: 'entityCreation',
       additionalData: { /* context */ }
     });
     
     // Return appropriate error to client
   }
   ```

2. **Error Boundaries**: Use the `ErrorBoundary` component to catch UI errors
   ```tsx
   import { ErrorBoundary } from '@/app/(authenticated)/components/error-boundary';
   
   // In your page component:
   <ErrorBoundary componentName="EntityForm">
     <EntityForm />
   </ErrorBoundary>
   ```

3. **Performance Monitoring**: Track key operations
   ```typescript
   // Measure operation time
   const startTime = performance.now();
   
   // After operation is complete
   const operationTime = performance.now() - startTime;
   
   // Include in analytics events
   trackFormSuccess({
     // ...
     processingTimeMs: operationTime,
   });
   ```

### 6. Create Server Actions with Cross-Cutting Concerns

Implement Server Actions that handle authentication, tenant isolation, normalization, and analytics:

```typescript
// app/(authenticated)/features/entity/actions/entity-actions.ts
'use server'

import { withAuth } from '@/app/utils/with-auth';
import { processEntityData } from '@repo/schema/src/pipeline/entity-pipeline';
import { 
  trackFormSuccess, 
  trackFormError,
  trackEntityCreated 
} from '@repo/analytics/posthog/actions/server-actions';

// Create entity
export const createEntity = withAuth(async ({ db, user }, prevState, formData) => {
  const startTime = performance.now();
  
  try {
    // Your implementation
    // ...
    
    // Track analytics events
    // ...
    
    return { success: true, data: result };
  } catch (error) {
    // Error handling
    // ...
    
    return { error: error.message };
  }
});
```

The `withAuth` utility provides:
- Authentication verification
- Tenant database connection
- User context retrieval
- Error handling and logging

### 7. Build Client Components with React 19 Features

Create form components using React 19's features and our normalized form components:

```tsx
// app/(authenticated)/features/entity/components/entity-form.tsx
'use client'
import { useActionState } from 'react';
import { createEntity } from '../actions/entity-actions';
import { TrackedForm } from '@repo/analytics/posthog/components/tracked-form';
import { NormalizedTextInput } from '@repo/design-system/components/form/normalized-text-input';

export function EntityForm({ initialData = {}, isEditing = false }) {
  // Form state with useActionState (React 19)
  const [state, formAction] = useActionState(
    createEntity, 
    { status: null, message: null }
  );
  
  // Your implementation
  // ...
}
```

### 8. Implement Optimistic Updates

For components that benefit from immediate feedback:

```tsx
// For list or action components
import { useOptimistic } from 'react';

export function EntityAction({ entity }) {
  // Optimistic state
  const [optimisticState, setOptimisticState] = useOptimistic(entity.state);
  
  // Implementation
  // ...
}
```

## Form Implementation Checklist

Use this checklist to ensure you've properly addressed all concerns:

### Schema and Data Processing
- [ ] Define entity schema with Zod
- [ ] Implement data processing pipeline (sanitize → normalize → validate)
- [ ] Track and report normalization changes

### Database Layer
- [ ] Define database schema
- [ ] Create query functions with proper tenant isolation
- [ ] Implement comprehensive error handling

### Analytics
- [ ] Use `TrackedForm` for form lifecycle events
- [ ] Track entity operations in server actions
- [ ] Include proper context in analytics events
- [ ] Measure and report performance metrics

### Server Actions
- [ ] Use `withAuth` for authentication and tenant isolation
- [ ] Implement proper error handling and reporting
- [ ] Add analytics event tracking
- [ ] Implement cache invalidation with revalidatePath

### Client Components
- [ ] Use `useActionState` for form state management
- [ ] Use normalized form components from design system
- [ ] Show normalization feedback to users
- [ ] Implement proper loading states

### Error Handling
- [ ] Use `ErrorBoundary` for component-level errors
- [ ] Use `captureError` for server-side errors
- [ ] Provide user-friendly error messages
- [ ] Track errors in analytics

## Standard Analytics Events

Our analytics package standardizes the following events:

### Form Events
- `form_viewed` - When a form is loaded
- `form_submitted` - When a form is submitted
- `form_abandoned` - When a user leaves without submitting
- `form_submission_succeeded` - Server-side success
- `form_submission_failed` - Server-side failure

### Entity Events
- `entity_created` - When any entity is created
- `entity_updated` - When any entity is modified
- `entity_deleted` - When any entity is removed
- `entity_viewed` - When any entity detail page is viewed

Include standard properties with these events:
- `entity_type` - Type of entity
- `entity_id` - ID of the entity (when applicable)
- `form_type` - Type of form
- `time_spent` - Duration of operation
- `fields_completed` - Number of fields completed
- `tenant_id` - Current tenant context

## Conclusion

By following this guide, you'll create forms that align with our architectural principles and leverage our existing infrastructure:

- Data quality through our normalization pipeline
- Comprehensive analytics with our tracking system
- Robust error handling with our observability package
- Great user experience with standardized components

These patterns are consistent with React 19's features and ensure a maintainable and scalable system.